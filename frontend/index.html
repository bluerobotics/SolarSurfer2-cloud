<html>
<meta http-equiv="refresh" content="600">
<head>
    <title>SolarSurfer Tracker 2.0</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.8.0/leaflet.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.8.0/leaflet.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-0evHe/X+R7YkIZDRvuzKMRqM+OrBnVFBL6DOitfPri4tjfHxaWutUpFmBp4vmVor" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/js/bootstrap.bundle.min.js" integrity="sha384-pprn3073KE6tl6bjs2QrFaJGz5/SUsLqktiwsUTF55Jfv3qYSDhgCecCxMW52nD2" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.3/moment.min.js"></script>
    <style>
        #map {
            width: 100%;
            height: 100%;
        }
    </style>
      <style type="text/css">
        html,
        body {
            font-family: Roboto;
            height: 100%;
            margin: 0;
            width: 100%
        }

        #wrapper {
            min-height: 100%;
        }

        #mapid {
            height: 100%;
            width: 100%;
        }

        #brand {
            position: absolute;
            z-index: 2000;
            width: auto;
            background-color: #FFFFFF;
            color: black;
            margin: 10px;
            margin-top: 1vh;
            border-radius: 10px;
            padding: 10px;
            width: 270px;
        }

        .brand-img {
            display: block;
            max-width: 250px;
        }

        .title {
            font-size: 1.2em;
            font-weight: bold;
            display: block;
        }

        .detail-label {
            font-weight: bold;
            font-size: 0.8em;
            display: inline-block;
            width: 75px;
        }

        #status-box {
            position: absolute;
            z-index: 2000;
            width: auto;
            background-color: #2699D0;
            color: white;
            margin: 10px;
            margin-top: 28vh;
            border-radius: 10px;
            padding: 10px;
            width: 270px;
        }

        #radius {
            width: 100%;
        }
    </style>
</head>

<body>
    <div id="brand">
        <a href="https://bluerobotics.com"><img src="https://bluerobotics.com/wp-content/uploads/2020/01/BlueRobotics-Logo-Blue-Black.png" class="brand-img" /></a>
        <hr />
        <span class="title">SolarSurfer Tracker 2.0</span>
        <span class="detail-label">Vehicle:</span> <em>Solar Turtle</em><br />
        <span class="detail-label">Departed:</span> 1 July 2022<br />
        <span class="detail-label">Origin:</span> Los Angeles, CA, USA<br />
        <span class="detail-label">Destination:</span> Kona, Hawaii, USA<br />
        <span class="detail-label">ETA:</span> 45-60 days
    </div>
    <div id="status-box">
        <span>Last update: </span><span id="last-update-time-span"></span></br>
        <hr />
        <strong>Last Segment:</strong><br />
        <span>Speed: </span><span id="current-speed-span"></span><span> m/s</span><br />
        <span>Solar power: </span><span id="current-solar-power-span"></span><span> W</span><br />
        <span>Battery voltage: </span><span id="current-battery-voltage-span"></span><span> V</span><br />
        <span>Power consumption: </span><span id="current-power-consumption-span"></span><span> W</span><br />
        <span>Net energy: </span><span id="current-net-energy-span"></span><span> Wh</span>
        <hr />
        <strong>Trip:</strong><br />
        <span>Total distance: </span><span id="total-distance-span"></span><span> km</span><br />
        <span>Total energy: </span><span id="total-energy-span"></span><span> Wh</span>
        <hr />
        <strong>Color Scale:</strong><br />
        <select id="color" onchange="replot(this)">
            <option value="perc2color(point['solar_panel_power'].map(0,180,0,100),0,180)">Solar Power</option>
            <option value="perc2color(point['battery_voltage'].map(160,210,0,100),-60,120)">Battery Voltage</option>
        </select>
    </br>
    </div>

    <div id="map"></div>

    <script>
        var map
        var layer
        Number.prototype.map = function (in_min, in_max, out_min, out_max) {
            return (this - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
        }
        function perc2color(percentage, minHue = 0, maxHue = 180) {
          const hue = percentage/100 * (maxHue - minHue) + minHue;
          return `hsl(${hue}, 100%, 50%)`;
        }

    function sleep (time) {
        return new Promise((resolve) => setTimeout(resolve, time));
    }

    function replot ()
    {
        fetch("/payloads?skip=0&limit=100000")
            .then(res => res.json())
            .then(data => {
                const expression = document.getElementById('color').value
                total = data.length

                // Populate status box
                sleep(100).then(() => {
                    const lastMessage = data[data.length - 1]    // Do something after the sleep!
                    const currentSolarPowerSpan = lastMessage['solar_panel_power']
                    document.getElementById('current-solar-power-span').innerHTML = currentSolarPowerSpan
                    const currentBatteryVoltage = parseFloat(lastMessage['battery_voltage']).toFixed(2)
                    document.getElementById('current-battery-voltage-span').innerHTML = currentBatteryVoltage
                    const currentPower = parseFloat(lastMessage['battery_power']).toFixed(1)
                    document.getElementById('current-power-consumption-span').innerHTML = currentPower
                    const currentSpeed = parseFloat(lastMessage['speed']).toFixed(1)
                    document.getElementById('current-speed-span').innerHTML = currentSpeed
                    const netEnergy = parseFloat(lastMessage['net_energy']).toFixed(0)
                    const netEnergySign = netEnergy > 0 ? "+" : ""
                    document.getElementById('current-net-energy-span').innerHTML = netEnergySign+netEnergy
                    const totalDistance = parseFloat(lastMessage['total_distance']).toFixed(1)
                    document.getElementById('total-distance-span').innerHTML = totalDistance
                    const totalEnergy = parseFloat(lastMessage['total_energy_consumed']).toFixed(0)
                    document.getElementById('total-energy-span').innerHTML = totalEnergy
                    const lastUpdateDateTime = new Date(parseFloat(lastMessage['time_unix_usec'] / 1000))
                    const timeSinceLastUpdate = moment(lastUpdateDateTime).fromNow();
                    document.getElementById('last-update-time-span').innerHTML = timeSinceLastUpdate
                });

                for (let n_point in data) {
                    point = data[n_point]
                    point["color"] = eval(expression)
                    point["heading"] = (point["heading"] * 360 / 255),
                    point["solar_panel_voltage"] = point["solar_panel_voltage"] * 64 / 255,
                    point["battery_current"] = point["battery_current"] * 64 / 255
                    point["battery_voltage"] = point["battery_voltage"] * 20 / 255
                    point["battery_power"] = point["battery_voltage"]*point["battery_current"]
                    point["left_motor_pwm"] = (point["left_motor_pwm"] - 127) * 100 / 127
                    point["right_motor_pwm"] = (point["right_motor_pwm"] - 127) * 100 / 127
                    point["distance_from_last"] = 0
                    point["total_distance"] = 0
                    point["time_since_last"] = 1800
                    point["speed"] = 0
                    point["total_energy_consumed"] = 0
                    point["energy_generated"] = 0
                    point["energy_consumed"] = 0
                    point["net_energy"] = 0
                    if ( n_point > 0 ) {
                        last = data[n_point-1]
                        const thisCoord = L.latLng(point["gps_lat"],point["gps_lon"])
                        const lastCoord = L.latLng(last["gps_lat"],last["gps_lon"])
                        point["distance_from_last"] = lastCoord.distanceTo(thisCoord)
                        point["time_since_last"] = (point["time_boot_ms"] - last["time_boot_ms"])/1000
                        point["speed"] = point["distance_from_last"]/point["time_since_last"]
                        point["total_distance"] = last["total_distance"]+point["distance_from_last"]
                        point["energy_generated"] = point["solar_panel_power"]*point["time_since_last"]/3600
                        point["energy_consumed"] = point["battery_voltage"]*point["battery_current"]*point["time_since_last"]/3600
                        point["net_energy"] = point["energy_generated"]-point["energy_consumed"]
                        point["total_energy_consumed"] = last["total_energy_consumed"]+point["energy_consumed"]
                    }
                }
                if (map == undefined) {
                    const last = data[data.length - 1]
                    map = L.map('map',{zoomControl:false}).setView([last["gps_lat"], last["gps_lon"]], 13);
                    layer = L.layerGroup()
                    layer.addTo(map);
                    new L.Control.Zoom({ position: 'topright' }).addTo(map);
                }
                layer.clearLayers();
                L.tileLayer('http://{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
                        maxZoom: 20,
                        subdomains: ['mt0', 'mt1', 'mt2', 'mt3']
                    }).addTo(layer);
                for (let n_point = 0; n_point < data.length - 2; n_point++) {
                    point = data[n_point]
                    next_point = data[n_point+1]
                    L.polyline([point, next_point].map(point => [point["gps_lat"], point["gps_lon"]]), {color:point["color"]}).addTo(layer)
                };

                for (const point of data) {
                    let marker = L.marker([point["gps_lat"], point["gps_lon"]], {
                        title: JSON.stringify(point, null, 2),
                        rotationAngle: point["heading"],
                        icon: L.divIcon({
                            html: `
                                <svg style="width:24px;height:24px" viewBox="0 0 24 24">
                                    <path fill="${point["color"]}" d="M15,20H9V12H4.16L12,4.16L19.84,12H15V20Z" />
                                </svg>`,
                            className: "",
                            iconSize: [24, 24],
                            iconAnchor: [12, 12],
                        })

                    })

                    map.on('mouseover', function (ev) {
                        ev?.layer?.openPopup()
                    })

                    marker.addTo(layer);
                }
            })
        }

        //From: https://github.com/bbecquet/Leaflet.RotatedMarker/blob/master/leaflet.rotatedMarker.js
        (function () {
            // save these original methods before they are overwritten
            var proto_initIcon = L.Marker.prototype._initIcon;
            var proto_setPos = L.Marker.prototype._setPos;

            var oldIE = (L.DomUtil.TRANSFORM === 'msTransform');

            L.Marker.addInitHook(function () {
                var iconOptions = this.options.icon && this.options.icon.options;
                var iconAnchor = iconOptions && this.options.icon.options.iconAnchor;
                if (iconAnchor) {
                    iconAnchor = (iconAnchor[0] + 'px ' + iconAnchor[1] + 'px');
                }
                this.options.rotationOrigin = this.options.rotationOrigin || iconAnchor || 'center bottom';
                this.options.rotationAngle = this.options.rotationAngle || 0;

                // Ensure marker keeps rotated during dragging
                this.on('drag', function (e) { e.target._applyRotation(); });
            });

            L.Marker.include({
                _initIcon: function () {
                    proto_initIcon.call(this);
                },

                _setPos: function (pos) {
                    proto_setPos.call(this, pos);
                    this._applyRotation();
                },

                _applyRotation: function () {
                    if (this.options.rotationAngle) {
                        this._icon.style[L.DomUtil.TRANSFORM + 'Origin'] = this.options.rotationOrigin;

                        if (oldIE) {
                            // for IE 9, use the 2D rotation
                            this._icon.style[L.DomUtil.TRANSFORM] = 'rotate(' + this.options.rotationAngle + 'deg)';
                        } else {
                            // for modern browsers, prefer the 3D accelerated version
                            this._icon.style[L.DomUtil.TRANSFORM] += ' rotateZ(' + this.options.rotationAngle + 'deg)';
                        }
                    }
                },

                setRotationAngle: function (angle) {
                    this.options.rotationAngle = angle;
                    this.update();
                    return this;
                },

                setRotationOrigin: function (origin) {
                    this.options.rotationOrigin = origin;
                    this.update();
                    return this;
                }
            });
        })();

        replot()
        setInterval(replot, 30000);
    </script>
</body>

</html>

