<html>
<meta http-equiv="refresh" content="600">

<head>
    <title>Solar Turtle Monitoring Room</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.8.0/leaflet.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.8.0/leaflet.js"></script>
    <script src="./L.KML.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-0evHe/X+R7YkIZDRvuzKMRqM+OrBnVFBL6DOitfPri4tjfHxaWutUpFmBp4vmVor" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-pprn3073KE6tl6bjs2QrFaJGz5/SUsLqktiwsUTF55Jfv3qYSDhgCecCxMW52nD2"
        crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.3/moment.min.js"></script>
    <script src="https://unpkg.com/vue@3"></script>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <style>
        #map {
            width: 100%;
            height: 100%;
        }
    </style>
    <style type="text/css">
        html,
        body {
            height: 100%;
            margin: 0;
            width: 100%
        }

        #wrapper {
            min-height: 100%;
        }

        #mapid {
            height: 100%;
            width: 100%;
        }

        #points-color-selector {
            position: absolute;
            z-index: 2000;
            width: auto;
            background-color: #2699D0;
            color: white;
            margin: 10px;
            margin-top: 12vh;
            border-radius: 10px;
            padding: 10px;
        }

        #status-box {
            position: absolute;
            z-index: 2000;
            width: auto;
            background-color: #2699D0;
            color: white;
            margin: 10px;
            margin-top: 28vh;
            border-radius: 10px;
            padding: 10px;
        }

        #radius {
            width: 100%;
        }
    </style>
</head>

<body>
    <div id="app">
        <div id="points-color-selector">
            <form @submit.prevent>
                <label>Color code</label><br>
                <select v-model="expression" id="color" @change="replot()">
                    <option value="perc2color(point['solar_panel_power'].map(0,180,0,100),0,180)">Solar Power</option>
                    <option value="perc2color(point['battery_voltage'].map(14.0,16.5,0,100),-60,120)">Battery Voltage</option>
                    <option value="perc2color((point['battery_voltage']*point['battery_current']).map(0,100,100,0))">Power
                        Consumption</option><br>
                    <option value="perc2color(point['speed'].map(0,1.5,0,100))">Speed</option>
                    <option value="perc2color(point['average_thrust'].map(0,20,0,100))">Average Thrust</option>
                </select>
                <br>
                <!-- <input type="text" v-model="expression" @change="replot()" /><br> -->
                <label>Points: {{numberOfPoints}}</label><br>
                <input type="range" min="10" :max="dataSeries.length" step="1" v-model="numberOfPoints"
                    @change="replot()" style="width: 100%;">

            </form>
        </div>
        <div id="status-box">
            <span>Last update: {{ lastUpdated }}</span></br>
            <hr />
            <strong>Last Segment:</strong><br />
            <span>Speed: {{ last ? last["speed"].toFixed(1) : "N/A"}} m/s</span><br>
            <span>Solar power: {{ last ? last["solar_panel_power"].toFixed(0) : "N/A" }} W</span></br>
            <span>Battery voltage: {{ last ? last["battery_voltage"].toFixed(2) : "N/A" }} V</span></br>
            <span>Power consumption: {{ last ? (last["battery_voltage"] * last["battery_current"]).toFixed(1) : "N/A"}}
                W</span></br>
            <span>Net energy: {{ last ? last["net_energy"] > 0 ? "+" : "" : "" }}{{ last ? last["net_energy"].toFixed(0) : "N/A "}} Wh</span></br>
            <hr />
            <span>Total Distance: {{ totalDistanceKm.toFixed(1) }} km</span></br>
            <span>Total Energy: {{ totalEnergy.toFixed(0) }} Wh</span></br>
            <span>Total Time: {{ totalTime }}</span></br>
            <span>Total Mission percentage: {{ missionPercentage.toFixed(2) }} %</span>
            </br>
        </div>

        <div id="map"></div>
    </div>

    <script>
        Number.prototype.map = function (in_min, in_max, out_min, out_max) {
            return (this - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
        }
        function perc2color(percentage, minHue = 0, maxHue = 180) {
            if (isNaN(percentage)) {
                percentage = 0
            }
            percentage = Math.min(Math.max(0, percentage), 100) // clamp between 0,100
            const hue = percentage / 100 * (maxHue - minHue) + minHue;
            return `hsl(${hue}, 100%, 50%)`;
        }
        Vue.createApp({
            el: "#app",
            data() {
                return {
                    dataSeries: [],
                    expression: "perc2color(point['solar_panel_power'].map(0,180,0,100),0,180)",
                    numberOfPoints: -1,
                    last: null,
                    currentSeries: [],
                    boatCoordinates: [],
                    kmlCoordinates: [],
                };
            },
            methods: {
                fetchNewData() {
                    axios.get("/payloads?skip=0&limit=100000")
                        .then(result => {
                            var data = result.data
                            total = data.length
                            if (this.numberOfPoints === -1) {
                                this.numberOfPoints = total
                            }

                            this.boatCoordinates = data.map(point => L.latLng(point["gps_lat"], point["gps_lon"]))

                            this.dataSeries = []
                            for (let n_point in data) {
                                point = data[n_point]
                                point["heading"] = (point["heading"] * 360 / 255),
                                    point["solar_panel_voltage"] = point["solar_panel_voltage"] * 64 / 255,
                                    point["battery_current"] = point["battery_current"] * 64 / 255
                                point["battery_voltage"] = point["battery_voltage"] * 20 / 255
                                point["left_motor_pwm"] = (point["left_motor_pwm"] - 127) * 100 / 127
                                point["right_motor_pwm"] = (point["right_motor_pwm"] - 127) * 100 / 127
                                point["power_consumption"] = point["battery_current"] * point["battery_voltage"]
                                point["average_thrust"] = (Math.abs(point["left_motor_pwm"]) + Math.abs(point["right_motor_pwm"])) / 2
                                // timedelta/speed calculation
                                if (n_point > 0) {
                                    const last = data[n_point - 1]
                                    const thisCoord = L.latLng(point["gps_lat"], point["gps_lon"])
                                    const lastCoord = L.latLng(last["gps_lat"], last["gps_lon"])
                                    point["distance_from_last"] = lastCoord.distanceTo(thisCoord)
                                    point["time_since_last"] = (point["time_boot_ms"] - last["time_boot_ms"]) / 1000
                                    point["speed"] = point["distance_from_last"] / point["time_since_last"]
                                    point["total_distance"] = last["total_distance"] + point["distance_from_last"]
                                    point["energy_generated"] = point["solar_panel_power"] * point["time_since_last"] / 3600
                                    point["energy_consumed"] = point["battery_voltage"] * point["battery_current"] * point["time_since_last"] / 3600
                                    point["net_energy"] = point["energy_generated"] - point["energy_consumed"]
                                    point["total_energy_consumed"] = last["total_energy_consumed"] + point["energy_consumed"]
                                }
                                else {
                                    point["time_since_last"] = 0
                                    point["distance_from_last"] = 0
                                    point["speed"] = 0
                                    point["energy_consumed"] = 0
                                    point["total_energy_consumed"] = 0
                                    point["total_distance"] = 0
                                }
                                this.dataSeries.push(point)
                            }
                            this.last = this.dataSeries[this.dataSeries.length - 1]
                            this.replot()
                        })
                },
                replot() {

                    this.currentSeries = this.dataSeries.slice(this.dataSeries.length - this.numberOfPoints)
                    if (this.map == undefined) {
                        const last = this.currentSeries[this.currentSeries.length - 1]
                        this.map = L.map('map').setView([last["gps_lat"], last["gps_lon"]], 13);
                        this.layer = L.layerGroup()
                        this.layer.addTo(this.map);
                    }
                    for (let n_point in this.currentSeries) {
                        point = this.currentSeries[n_point]
                        point["color"] = eval(this.expression)

                    }
                    this.layer.clearLayers();
                    L.tileLayer('http://{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
                        maxZoom: 20,
                        subdomains: ['mt0', 'mt1', 'mt2', 'mt3']
                    }).addTo(this.layer);

                    for (let n_point = 0; n_point < this.currentSeries.length - 2; n_point++) {
                        point = this.currentSeries[n_point]
                        next_point = this.currentSeries[n_point + 1]
                        L.polyline([point, next_point].map(point => [point["gps_lat"], point["gps_lon"]]), { color: point["color"] }).addTo(this.layer)
                    };

                    for (const point of this.currentSeries) {
                        let marker = L.marker([point["gps_lat"], point["gps_lon"]], {
                            title: JSON.stringify(point, null, 2),
                            rotationAngle: point["heading"],
                            icon: L.divIcon({
                                html: `
                                        <svg style="width:24px;height:24px" viewBox="0 0 24 24">
                                            <path fill="${point["color"]}" d="M15,20H9V12H4.16L12,4.16L19.84,12H15V20Z" />
                                        </svg>`,
                                className: "",
                                iconSize: [24, 24],
                                iconAnchor: [12, 12],
                            })

                        })

                        this.map.on('mouseover', function (ev) {
                            ev?.layer?.openPopup()
                        })

                        marker.addTo(this.layer);
                    }
                    fetch('mission.kml')
                        .then(res => res.text())
                        .then(kmltext => {
                            // Create new kml overlay
                            const parser = new DOMParser();
                            const kml = parser.parseFromString(kmltext, 'text/xml');
                            const track = new L.KML(kml);
                            this.kmlCoordinates = track.latLngs
                            this.map.addLayer(track);

                        });
                },


                //From: https://github.com/bbecquet/Leaflet.RotatedMarker/blob/master/leaflet.rotatedMarker.js
                createMap() {
                    // save these original methods before they are overwritten
                    var proto_initIcon = L.Marker.prototype._initIcon;
                    var proto_setPos = L.Marker.prototype._setPos;

                    var oldIE = (L.DomUtil.TRANSFORM === 'msTransform');

                    L.Marker.addInitHook(function () {
                        var iconOptions = this.options.icon && this.options.icon.options;
                        var iconAnchor = iconOptions && this.options.icon.options.iconAnchor;
                        if (iconAnchor) {
                            iconAnchor = (iconAnchor[0] + 'px ' + iconAnchor[1] + 'px');
                        }
                        this.options.rotationOrigin = this.options.rotationOrigin || iconAnchor || 'center bottom';
                        this.options.rotationAngle = this.options.rotationAngle || 0;

                        // Ensure marker keeps rotated during dragging
                        this.on('drag', function (e) { e.target._applyRotation(); });
                    });

                    L.Marker.include({
                        _initIcon: function () {
                            proto_initIcon.call(this);
                        },

                        _setPos: function (pos) {
                            proto_setPos.call(this, pos);
                            this._applyRotation();
                        },

                        _applyRotation: function () {
                            if (this.options.rotationAngle) {
                                this._icon.style[L.DomUtil.TRANSFORM + 'Origin'] = this.options.rotationOrigin;

                                if (oldIE) {
                                    // for IE 9, use the 2D rotation
                                    this._icon.style[L.DomUtil.TRANSFORM] = 'rotate(' + this.options.rotationAngle + 'deg)';
                                } else {
                                    // for modern browsers, prefer the 3D accelerated version
                                    this._icon.style[L.DomUtil.TRANSFORM] += ' rotateZ(' + this.options.rotationAngle + 'deg)';
                                }
                            }
                        },

                        setRotationAngle: function (angle) {
                            this.options.rotationAngle = angle;
                            this.update();
                            return this;
                        },

                        setRotationOrigin: function (origin) {
                            this.options.rotationOrigin = origin;
                            this.update();
                            return this;
                        }
                    });
                },
            },
            mounted() {
                this.createMap()
                this.fetchNewData()
                setInterval(this.fetchNewData, 30000);
            },
            computed: {
                missionPercentage() {
                    return 100.0 * this.totalDistanceKm / this.missionTotalDistanceKm
                },
                lastUpdated() {
                    return this.last ? moment(new Date(parseFloat(this.last['time_unix_usec'] / 1000))).fromNow() : "n/a"
                },
                missionTotalDistanceKm() {
                    return this.kmlCoordinates
                        .slice(1)
                        .map(
                            (value, index) =>
                                value.distanceTo(this.kmlCoordinates[index])
                        )
                        .reduce((a, b) => a + b, 0) / 1000;
                },
                totalTimeMinutes() {
                    const first = this.currentSeries[0]
                    if (first === undefined) {
                        return 0
                    }

                    return (Date.now() - parseFloat(first['time_unix_usec'] / 1000)) / (60e3)
                },
                totalTime() {
                    const days = Math.floor(this.totalTimeMinutes / (24 * 60))
                    const hours = Math.floor((this.totalTimeMinutes / 60) % 24)
                    const minutes = Math.floor(this.totalTimeMinutes % 60)
                    return `${days} days, ${hours} hours, ${minutes} minutes`
                },
                totalDistanceKm() {
                    let sum = 0
                    for (const point of this.currentSeries) {
                        sum = sum + point["distance_from_last"]
                    }
                    return sum / 1000
                },
                totalEnergy() {
                    let sum = 0
                    for (const point of this.currentSeries) {
                        sum = sum + point["energy_consumed"]
                    }
                    return sum
                },
            }
        }).mount("#app")
    </script>
</body>

</html>