<html>
<meta http-equiv="refresh" content="600">
<head>
    <title>Solar Turtle Monitoring Room</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.8.0/leaflet.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.8.0/leaflet.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-0evHe/X+R7YkIZDRvuzKMRqM+OrBnVFBL6DOitfPri4tjfHxaWutUpFmBp4vmVor" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/js/bootstrap.bundle.min.js" integrity="sha384-pprn3073KE6tl6bjs2QrFaJGz5/SUsLqktiwsUTF55Jfv3qYSDhgCecCxMW52nD2" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.3/moment.min.js"></script>
    <style>
        #map {
            width: 100%;
            height: 100%;
        }
    </style>
      <style type="text/css">
        html,
        body {
            height: 100%;
            margin: 0;
            width: 100%
        }

        #wrapper {
            min-height: 100%;
        }

        #mapid {
            height: 100%;
            width: 100%;
        }

        #points-color-selector {
            position: absolute;
            z-index: 2000;
            width: auto;
            background-color: #2699D0;
            color: white;
            margin: 10px;
            margin-top: 12vh;
            border-radius: 10px;
            padding: 10px;
        }

        #status-box {
            position: absolute;
            z-index: 2000;
            width: auto;
            background-color: #2699D0;
            color: white;
            margin: 10px;
            margin-top: 26vh;
            border-radius: 10px;
            padding: 10px;
        }

        #radius {
            width: 100%;
        }
    </style>
</head>

<body>
    <div id="points-color-selector">
        <form action="/generate" method="post">
            <label>Color code</label><br>
            <select id="color" onchange="replot(this)">
                <option value="point['solar_panel_power'].map(0,180,0,100)">Solar Power</option>
                <option value="point['battery_voltage'].map(130,220,0,100)">Battery Voltage</option>
            </select>
        </form>
    </div>
    <div id="status-box">
        <span>Last update: </span><span id="last-update-time-span"></span></br>
        <span>Last solar power: </span><span id="current-solar-power-span"></span><span> W</span></br>
        <span>Last battery voltage: </span><span id="current-battery-voltage-span"></span><span> V</span></br>
        <span>Last power consumption: </span><span id="current-power-consumption-span"></span><span> W</span>
    </br>
    </div>

    <div id="map"></div>

    <script>
        var map
        var layer
        Number.prototype.map = function (in_min, in_max, out_min, out_max) {
            return (this - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
        }
        // linear color interpolation from red to green
        function perc2color(perc) {
            var r, g, b = 0;
            if(perc < 50) {
                r = 255;
                g = Math.round(5.1 * perc);
            }
            else {
                g = 255;
                r = Math.round(510 - 5.10 * perc);
            }
            var h = r * 0x10000 + g * 0x100 + b * 0x1;
            return '#' + ('000000' + h.toString(16)).slice(-6);
        }

    function sleep (time) {
        return new Promise((resolve) => setTimeout(resolve, time));
    }

    function replot ()
    {
        fetch("/payloads?skip=0&limit=100000")
            .then(res => res.json())
            .then(data => {
                const expression = document.getElementById('color').value
                total = data.length

                // Populate status box
                sleep(100).then(() => {
                    const lastMessage = data[data.length - 1]    // Do something after the sleep!
                    const currentSolarPowerSpan = lastMessage['solar_panel_power']
                    document.getElementById('current-solar-power-span').innerHTML = currentSolarPowerSpan
                    const currentBatteryVoltage = parseFloat(lastMessage['battery_voltage']).toFixed(2)
                    document.getElementById('current-battery-voltage-span').innerHTML = currentBatteryVoltage
                    const currentPower = (parseFloat(lastMessage['battery_voltage'])*parseFloat(lastMessage['battery_current'])).toFixed(2)
                    document.getElementById('current-power-consumption-span').innerHTML = currentPower
                    const lastUpdateDateTime = new Date(parseFloat(lastMessage['time_unix_usec'] / 1000))
                    const timeSinceLastUpdate = moment(lastUpdateDateTime).fromNow();
                    document.getElementById('last-update-time-span').innerHTML = timeSinceLastUpdate
                });

                for (let n_point in data) {
                    point = data[n_point]
                    point["color"] = perc2color(eval(expression))
                    point["heading"] = (point["heading"] * 360 / 255),
                        point["solar_panel_voltage"] = point["solar_panel_voltage"] * 64 / 255,
                        point["battery_current"] = point["battery_current"] * 64 / 255
                    point["battery_voltage"] = point["battery_voltage"] * 20 / 255
                    point["left_motor_pwm"] = (point["left_motor_pwm"] - 127) * 100 / 127
                    point["right_motor_pwm"] = (point["right_motor_pwm"] - 127) * 100 / 127
                }
                if (map == undefined) {
                    const last = data[data.length - 1]
                    map = L.map('map').setView([last["gps_lat"], last["gps_lon"]], 13);
                    layer = L.layerGroup()
                    layer.addTo(map);
                }
                layer.clearLayers();
                L.tileLayer('http://{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
                        maxZoom: 20,
                        subdomains: ['mt0', 'mt1', 'mt2', 'mt3']
                    }).addTo(layer);
                for (let n_point = 0; n_point < data.length - 2; n_point++) {
                    point = data[n_point]
                    next_point = data[n_point+1]
                    L.polyline([point, next_point].map(point => [point["gps_lat"], point["gps_lon"]]), {color:point["color"]}).addTo(layer)
                };

                for (const point of data) {
                    let marker = L.marker([point["gps_lat"], point["gps_lon"]], {
                        title: JSON.stringify(point, null, 2),
                        rotationAngle: point["heading"],
                        icon: L.divIcon({
                            html: `
                                <svg style="width:24px;height:24px" viewBox="0 0 24 24">
                                    <path fill="${point["color"]}" d="M15,20H9V12H4.16L12,4.16L19.84,12H15V20Z" />
                                </svg>`,
                            className: "",
                            iconSize: [24, 24],
                            iconAnchor: [12, 12],
                        })

                    })

                    map.on('mouseover', function (ev) {
                        ev?.layer?.openPopup()
                    })

                    marker.addTo(layer);
                }
            })
        }

        //From: https://github.com/bbecquet/Leaflet.RotatedMarker/blob/master/leaflet.rotatedMarker.js
        (function () {
            // save these original methods before they are overwritten
            var proto_initIcon = L.Marker.prototype._initIcon;
            var proto_setPos = L.Marker.prototype._setPos;

            var oldIE = (L.DomUtil.TRANSFORM === 'msTransform');

            L.Marker.addInitHook(function () {
                var iconOptions = this.options.icon && this.options.icon.options;
                var iconAnchor = iconOptions && this.options.icon.options.iconAnchor;
                if (iconAnchor) {
                    iconAnchor = (iconAnchor[0] + 'px ' + iconAnchor[1] + 'px');
                }
                this.options.rotationOrigin = this.options.rotationOrigin || iconAnchor || 'center bottom';
                this.options.rotationAngle = this.options.rotationAngle || 0;

                // Ensure marker keeps rotated during dragging
                this.on('drag', function (e) { e.target._applyRotation(); });
            });

            L.Marker.include({
                _initIcon: function () {
                    proto_initIcon.call(this);
                },

                _setPos: function (pos) {
                    proto_setPos.call(this, pos);
                    this._applyRotation();
                },

                _applyRotation: function () {
                    if (this.options.rotationAngle) {
                        this._icon.style[L.DomUtil.TRANSFORM + 'Origin'] = this.options.rotationOrigin;

                        if (oldIE) {
                            // for IE 9, use the 2D rotation
                            this._icon.style[L.DomUtil.TRANSFORM] = 'rotate(' + this.options.rotationAngle + 'deg)';
                        } else {
                            // for modern browsers, prefer the 3D accelerated version
                            this._icon.style[L.DomUtil.TRANSFORM] += ' rotateZ(' + this.options.rotationAngle + 'deg)';
                        }
                    }
                },

                setRotationAngle: function (angle) {
                    this.options.rotationAngle = angle;
                    this.update();
                    return this;
                },

                setRotationOrigin: function (origin) {
                    this.options.rotationOrigin = origin;
                    this.update();
                    return this;
                }
            });
        })();

        replot()
        setInterval(replot, 30000);
    </script>
</body>

</html>

